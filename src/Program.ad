var Source: string = "";
var Token: string = "";
var NextTokenPosition: int = 0;
// TODO should be `new mut`
let Declarations: mut System.Text.StringBuilder = new System.Text.StringBuilder();
let ClassDeclarations: mut System.Text.StringBuilder = new System.Text.StringBuilder();
let Definitions: mut System.Text.StringBuilder = new System.Text.StringBuilder();
var IndentDepth: int = 0;
var AfterDeclaration: bool = false;
var MainFunctionReturnType: string = "";
var MainFunctionAcceptsConsole: bool = false;
var MainFunctionAcceptsArgs: bool = false;

// ----------------------------------------------------------------------------
// Code Writing
// ----------------------------------------------------------------------------

Error(message: string) -> void
{
	Definitions.Append("<$ " + message + " $>");
}

BeginLine(value: string) -> void
{
	if AfterDeclaration
	{
		Definitions.AppendLine();
		AfterDeclaration = false;
	}
	Definitions.Append(new string('\t', IndentDepth));
	Definitions.Append(value);
}

Write(value: string) -> void
{
	Definitions.Append(value);
}

EndLine(value: string) -> void
{
	Definitions.Append(value);
	Definitions.AppendLine(); // TODO need to think about the handling of newlines
}

WriteLine(value: string) -> void
{
	if AfterDeclaration
	{
		Definitions.AppendLine();
		AfterDeclaration = false;
	}
	Definitions.Append(new string('\t', IndentDepth));
	Definitions.Append(value);
	Definitions.AppendLine();
}

BeginBlock() -> void
{
	WriteLine("{");
	IndentDepth += 1;
}

EndBlock() -> void
{
	AfterDeclaration = false; // so that we don't put a blank line between two closing braces
	IndentDepth -= 1;
	WriteLine("}");
	AfterDeclaration = true;
}

// ----------------------------------------------------------------------------
// Lexer
// ----------------------------------------------------------------------------

IsIdentifierChar(c: code_point) -> bool
{
	return (c >= 'a' and c <= 'z') or (c >= 'A' and c <= 'Z') or c == '_';
}

IsNumberChar(c: code_point) -> bool
{
	return c >= '0' and c <= '9';
}

ReadToken() -> void
{
	var position: int = NextTokenPosition;
	var tokenEnd: int = -1;
	var escaped: bool;
	var done: bool = false;
	while not done and position < Source.Length
	{
		let curChar: code_point = Source[position];
		if curChar == ' '
			or curChar == '\t'
			or curChar == '\n'
			or curChar == '\r'
		{
			position += 1;
			continue;
		}
		else if curChar == '{'
			or curChar == '}'
			or curChar == '('
			or curChar == ')'
			or curChar == ';'
			or curChar == ','
			or curChar == '.'
			or curChar == ':'
			or curChar == '['
			or curChar == ']'
		{
			tokenEnd = position + 1;
			break;
		}
		else if curChar == '='
		{
			if position + 1 < Source.Length and Source[position + 1] == '='
			{
				// it is `==`
				tokenEnd = position + 2;
				break;
			}

			// it is `=`
			tokenEnd = position + 1;
			break;
		}
		else if curChar == '+'
		{
			if position + 1 < Source.Length and Source[position + 1] == '='
			{
				// it is `+=`
				tokenEnd = position + 2;
				break;
			}

			// it is `+`
			tokenEnd = position + 1;
			break;
		}
		else if curChar == '-'
		{
			if position + 1 < Source.Length and Source[position + 1] == '>'
			{
				// it is `->`
				tokenEnd = position + 2;
				break;
			}
			if position + 1 < Source.Length and Source[position + 1] == '='
			{
				// it is `-=`
				tokenEnd = position + 2;
				break;
			}
			// it is `-`
			tokenEnd = position + 1;
			break;
		}
		else if curChar == '/'
		{
			if position + 1 < Source.Length and Source[position + 1] == '/'
			{
				// it is a line comment `//`
				while position < Source.Length and Source[position] <> '\r' and Source[position] <> '\n'
				{
					position += 1;
				}

				continue;
			}
			// it is `/`
			tokenEnd = position + 1;
			break;
		}
		else if curChar == '<'
		{
			if position + 1 < Source.Length and Source[position + 1] == '>'
			{
				// it is `<>`
				tokenEnd = position + 2;
				break;
			}
			if position + 1 < Source.Length and Source[position + 1] == '='
			{
				// it is `<=`
				tokenEnd = position + 2;
				break;
			}
			// it is `<`
			tokenEnd = position + 1;
			break;
		}
		else if curChar == '>'
		{
			if position + 1 < Source.Length and Source[position + 1] == '='
			{
				// it is `>=`
				tokenEnd = position + 2;
				break;
			}
			// it is `>`
			tokenEnd = position + 1;
			break;
		}
		else if curChar == '"'
		{
			tokenEnd = position + 1;
			escaped = false;
			while tokenEnd < Source.Length and (Source[tokenEnd] <> '"' or escaped)
			{
				escaped = Source[tokenEnd] == '\\' and not escaped;
				tokenEnd += 1;
			}

			tokenEnd += 1; // To include the close quote
			break;
		}
		else if curChar == '\''
		{
			tokenEnd = position + 1;
			escaped = false;
			while tokenEnd < Source.Length and (Source[tokenEnd] <> '\'' or escaped)
			{
				escaped = Source[tokenEnd] == '\\' and not escaped;
				tokenEnd += 1;
			}

			tokenEnd += 1; // To include the close quote
			break;
		}
		else
		{
			if IsIdentifierChar(curChar)
			{
				tokenEnd = position + 1;
				while IsIdentifierChar(Source[tokenEnd])
				{
					tokenEnd += 1;
				}
				break;
			}
			if(IsNumberChar(curChar))
			{
				tokenEnd = position + 1;
				while IsNumberChar(Source[tokenEnd])
				{
					tokenEnd += 1;
				}
				break;
			}
			Error("Lexer: Invalid character `" + curChar + "`");
			position += 1;
		}
	}

	if tokenEnd == -1
	{
		Token = ""; // TODO need nullable string so we can set it to null
		NextTokenPosition = position;
	}
	else
	{
		Token = Source.Substring(position, tokenEnd - position);
		NextTokenPosition = tokenEnd;
	}
}

ReadFirstToken() -> void
{
	if NextTokenPosition <> 0
	{
		Error("Can't read first token of context that already has tokens read.");
	}

	ReadToken();
}

TokenIsIdentifier() -> bool
{
	if Token.Length == 0
		{ return false; }

	for let c: code_point in Token
	{
		if not IsIdentifierChar(c)
			{ return false; }
	}
	return true;
}

Accept(expected: string) -> bool
{
	let accepted: bool = Token == expected;
	if accepted { ReadToken(); }
	return accepted;
}

Expect(expected: string) -> void
{
	if Token <> expected
	{
		Error("Expected `" + expected + "` but found `" + Token + "`");
		ReadToken(); // Skip token to advance
	}
	else
	{
		ReadToken();
	}
}

AcceptIdentifier() -> bool
{
	if not TokenIsIdentifier() { return false; }
	ReadToken();
	return true;
}

AcceptString() -> bool
{
	if Token.Length == 0 or Token[0] <> '"'
		{ return false; }

	ReadToken();
	return true;
}

AcceptCodePoint() -> bool
{
	if Token.Length == 0 or Token[0] <> '\''
		{ return false; }

	ReadToken();
	return true;
}

AcceptNumber() -> bool
{
	for let c: code_point in Token
	{
		if not IsNumberChar(c)
			{ return false; }
	}

	ReadToken();
	return true;
}

ExpectIdentifier() -> string
{
	if not TokenIsIdentifier()
	{
		Error("Expected identifier, found `" + Token + "`");
		ReadToken(); // Skip token to advance
		return "<missing>";
	}

	let identifier: string = Token;
	ReadToken();
	return identifier;
}

// ----------------------------------------------------------------------------
// Parser
// ----------------------------------------------------------------------------

IsValueType(type: string) -> bool
{
	// Here we assume that they follow convention and value types start lowercase
	let firstChar: code_point = type[0];
	return firstChar >= 'a' and firstChar <= 'z';
}

ConvertType(type: string) -> string
{
	if type == "code_point"
		{ return "char"; }
	if IsValueType(type)
		{ return type; }

	return "::" + type.Replace(".", "::");
}

// TODO should be `var type: string` so we don't need separate result variable
ConvertType(mutableBinding: bool, mutableValue: bool, var type: string) -> string
{
	let isValueType: bool = IsValueType(type);
	type = ConvertType(type);

	if isValueType
	{
		if not mutableBinding and not mutableValue
			{ type = type + " const"; }
	}
	else
	{
		if not mutableValue { type = type + " const"; }
		type = type + " *";
		if not mutableBinding { type = type + "const" ; }
	}

	return type;
}

ParseType() -> string
{
	// TODO should be `new mut`
	let type: mut System.Text.StringBuilder = new System.Text.StringBuilder(ExpectIdentifier());
	while Accept(".")
	{
		type.Append(".");
		type.Append(ExpectIdentifier());
	}

	return type.ToString();
}

// An Atom is the unit of an expression that occurs between infix operators, i.e. an identifier, literal, group, or new
ParseAtom() -> bool
{
	if Accept("new")
	{
		// Constructor Call
		var type: string = ParseType();
		if not IsValueType(type) // place value types on the stack in C++ by not using new
			{ Write("new "); }
		type = ConvertType(type);
		Write(type);
		Expect("(");
		Write("(");
		ParseCallArguments();
		Expect(")");
		Write(")");
		return true;
	}
	if Accept("not")
	{
		Write("!");
		ParseExpression();
		return true;
	}
	if Accept("(") // Order of operations parens
	{
		Write("(");
		ParseExpression();
		Expect(")");
		Write(")");
		return true;
	}
	if Accept("-")
	{
		// Unary Minus
		Write("-");
		ParseExpression(7);
		return true;
	}

	let token: string = Token;
	if AcceptIdentifier() or AcceptNumber()
	{
		Write(token);
		return true;
	}
	if AcceptString()
	{
		Write("string(" + token + ")");
		return true;
	}
	if AcceptCodePoint()
	{
		Write(token);
		return true;
	}

	return false;
}

ParseCallArguments() -> void
{
	var first: bool = true;
	do
	{
		if first { first = false; }
		else { Write(", "); }
		ParseExpression();
	} while Accept(",");
}

// Operator Precedence
// 1 Assignment: = += -=
// 2 Logical Or: or
// 3 Logical And: and
// 4 Equality: == <>
// 5 Relational: < <= > >=
// 6 Additive: + -
// 7 Unary: -
// 8 Primary: f() . []
ParseExpression(minPrecedence: int) -> void
{
	if not ParseAtom() { return; }

	loop
	{
		let token: string = Token;
		var precedence: int;
		var leftAssociative: bool;
		var suffixOperator: bool = false;
		if (token == "=" or token == "+=" or token == "-=") and minPrecedence <= 1
		{
			// Assignment
			precedence = 1;
			leftAssociative = false;
			Write(" " + token + " ");
		}
		else if token == "or" and minPrecedence <= 2
		{
			// logical or
			precedence = 2;
			leftAssociative = true;
			Write(" || ");
		}
		else if token == "and" and minPrecedence <= 3
		{
			// logical and
			precedence = 3;
			leftAssociative = true;
			Write(" && ");
		}
		else if token == "==" and minPrecedence <= 4
		{
			// equal
			precedence = 4;
			leftAssociative = true;
			Write(" == ");
		}
		else if token == "<>" and minPrecedence <= 4
		{
			// not equal
			precedence = 4;
			leftAssociative = true;
			Write(" != ");
		}
		else if (token == "<" or token == "<=" or token == ">" or token == ">=") and minPrecedence <= 5
		{
			// relational operators
			precedence = 5;
			leftAssociative = true;
			Write(" " + token + " ");
		}
		else if (token == "+" or token == "-") and minPrecedence <= 6
		{
			// Additive
			precedence = 6;
			leftAssociative = true;
			Write(" " + token + " ");
		}
		else if token == "(" and minPrecedence <= 8
		{
			// Call Expression
			ReadToken();
			Write("(");
			ParseCallArguments();
			if Token <> ")"
			{
				Error("Expected `)` found `" + Token + "`");
			}
			Write(")");
			precedence = 8;
			leftAssociative = true;
			suffixOperator = true;
		}
		else if token == "." and minPrecedence <= 8
		{
			// Member Access
			precedence = 8;
			leftAssociative = true;
			Write("->");
		}
		else if token == "[" and minPrecedence <= 8
		{
			// Element Access
			ReadToken();
			Write("[");
			ParseExpression();
			if Token <> "]"
			{
				Error("Expected `]` found `" + Token + "`");
			}
			Write("]");
			precedence = 8;
			leftAssociative = true;
			suffixOperator = true;
		}
		else
		{
			break;
		}

		ReadToken();
		if not suffixOperator
		{
			if leftAssociative { precedence += 1; }
			ParseExpression(precedence);
		}
	}
}

ParseExpression() -> void
{
	ParseExpression(1);
}

ParseStatement() -> bool
{
	if Accept("return")
	{
		if  Accept(";")
			{ WriteLine("return;"); }
		else
		{
			BeginLine("return ");
			ParseExpression();
			Expect(";");
			EndLine(";");
		}
		return true;
	}
	if Accept("loop")
	{
		WriteLine("for (;;)");
		ParseBlock();
		return true;
	}
	if Accept("while")
	{
		BeginLine("while (");
		ParseExpression();
		EndLine(")");
		ParseBlock();
		return true;
	}
	if Accept("for")
	{
		BeginLine("for (");
		let k: string = Token;
		if not Accept("let") and not Accept("var")
			{ Error("Expected `let` or `var` but found `" + Token + "`"); }
		let name: string = ExpectIdentifier();
		Expect(":");
		let mutableValue: bool = Accept("mut");
		let type: string = ParseType();
		Write(ConvertType(k == "var", mutableValue, type) + " " + name);
		Expect("in");
		Write(" : *(");
		ParseExpression();
		EndLine("))");
		ParseBlock();
		return true;
	}
	if Accept("do")
	{
		WriteLine("do");
		ParseBlock();
		AfterDeclaration = false;
		Expect("while");
		BeginLine("while (");
		ParseExpression();
		Expect(";");
		EndLine(");");
		return true;
	}

	if Accept("if")
	{
		BeginLine("if (");
		ParseExpression();
		EndLine(")");
		ParseBlock();
		while Accept("else")
		{
			AfterDeclaration = false;
			if Accept("if")
			{
				BeginLine("else if (");
				ParseExpression();
				EndLine(")");
				ParseBlock();
			}
			else
			{
				WriteLine("else");
				ParseBlock();
				return true;
			}
		}
		return true;
	}
	let kind: string = Token;
	if Accept("let") or Accept("var")
	{
		let variableName: string = ExpectIdentifier();
		Expect(":");
		let mutableValue: bool = Accept("mut");
		var variableType: string = ParseType();
		variableType = ConvertType(kind == "var", mutableValue, variableType);
		BeginLine(variableType);
		Write(" " + variableName);
		if Accept("=")
		{
			Write(" = ");
			ParseExpression();
		}
		Expect(";");
		EndLine(";");
		return true;
	}
	if Token == "}" { return false; }

	// Assume it is an expression statement
	BeginLine("");
	ParseExpression();
	Expect(";");
	EndLine(";");
	return true;
}

ParseBlock() -> void
{
	Expect("{");
	BeginBlock();
	while ParseStatement() {}
	Expect("}");
	EndBlock();
}

ParseArgumentsDeclaration(isMainFunction: bool) -> string
{
	Expect("(");
	if Accept(")") { return ""; }

	// TODO should be `new mut`
	let arguments: mut System.Text.StringBuilder = new System.Text.StringBuilder();
	do
	{
		let mutableBinding: bool = Accept("var");
		let name: string = ExpectIdentifier();
		Expect(":");
		let mutableValue: bool = Accept("mut");
		let type: string = ParseType();
		if isMainFunction
		{
			if type == "System.Console.Console"
				{ MainFunctionAcceptsConsole = true; }
			if type == "System.Console.Arguments"
				{ MainFunctionAcceptsArgs = true; }
		}
		arguments.Append(ConvertType(mutableBinding, mutableValue, type) + " " + name + ", ");
	} while Accept(",");
	Expect(")");
	let result: string = arguments.ToString();
	// TODO implement shortening of StringBuilder
	return result.Substring(0, result.Length - 2); // remove the trailing comma and space
}

ParseClassMember(className: string) -> void
{
	let accessModifier: string = Token;
	if Accept("public") or Accept("internal") or Accept("protected") or Accept("private")
	{
		// TODO currently not doing anything with the access modifier
	}
	else
	{
		Error("Expected access modifier, found `" + accessModifier + "`");
	}

	if Accept("new")
	{
		// Constructor
		let arguments: string = ParseArgumentsDeclaration(false);
		// Write out the function declaration for C++ so we can call functions defined after others
		ClassDeclarations.AppendLine("\t" + className + "(" + arguments + ");");
		WriteLine("::" + className + "::" + className + "(" + arguments + ")");
		ParseBlock();
	}

	let kind: string = Token;
	if Accept("var") or Accept("let")
	{
		let fieldName: string = ExpectIdentifier();
		Expect(":");
		let mutableValue: bool = Accept("mut");
		var fieldType: string = ParseType();
		fieldType = ConvertType(true, mutableValue, fieldType); // because we need to assign them in constructors don't mark fields const
		Expect(";");
		ClassDeclarations.AppendLine("\t" + fieldType + " " + fieldName + ";");
		return;
	}
}

ParseDeclaration() -> void
{
	let accessModifier: string = Token;
	if Accept("public") or Accept("internal")
	{
		// TODO currently not doing anything with the access modifier
	}

	// Static Variable Declaration
	let kind: string = Token;
	if Accept("var") or Accept("let")
	{
		let variableName: string = ExpectIdentifier();
		Expect(":");
		let mutableValue: bool = Accept("mut");
		var variableType: string = ParseType();
		Expect("=");
		variableType = ConvertType(kind == "var", mutableValue, variableType);
		BeginLine(variableType);
		Write(" " + variableName + " = ");
		ParseExpression();
		Expect(";");
		EndLine(";");
		AfterDeclaration = true;
		return;
	}

	if Accept("class")
	{
		let className: string = ExpectIdentifier();
		Declarations.AppendLine("class " + className + ";");
		ClassDeclarations.AppendLine("class " + className);
		Expect("{");
		ClassDeclarations.AppendLine("{");
		ClassDeclarations.AppendLine("public:");
		while not Accept("}")
		{
			ParseClassMember(className);
		}
		ClassDeclarations.AppendLine("};");
		return;
	}

	// Function Declaration
	let name: string = ExpectIdentifier();
	let arguments: string = ParseArgumentsDeclaration(name == "Main");
	Expect("->");
	let mutableValue: bool = Accept("mut");
	let returnType: string = ParseType();
	let convertedReturnType: string = ConvertType(true, mutableValue, returnType);
	// Write out the function declaration for C++ so we can call functions defined after others
	Declarations.AppendLine(convertedReturnType + " " + name + "(" + arguments + ");");
	WriteLine(convertedReturnType + " " + name + "(" + arguments + ")");
	if name == "Main"
	{
		if MainFunctionReturnType <> ""
			{ Error("Multiple declarations of main"); }
		MainFunctionReturnType = returnType;
	}
	ParseBlock();
}

ParseProgram() -> void
{
	// Setup the beginning of each section
	Declarations.AppendLine("#include \"runtime.h\"");
	Declarations.AppendLine("");
	Declarations.AppendLine("// Declarations");
	ClassDeclarations.AppendLine("");
	ClassDeclarations.AppendLine("// Class Declarations");
	WriteLine("");
	WriteLine("// Definitions");

	do
	{
		ParseDeclaration();
	} while TokenIsIdentifier();
	WriteLine("// Entry Point Adapter");
	WriteLine("int main(int argc, char const *const * argv)");
	BeginBlock();

	// TODO should be `new mut`
	let args: mut System.Text.StringBuilder = new System.Text.StringBuilder();
	if MainFunctionAcceptsConsole
		{ args.Append("new ::System::Console::Console()"); }
	if MainFunctionAcceptsArgs
	{
		if MainFunctionAcceptsConsole
			{ args.Append(", "); }
		args.Append("new ::System::Console::Arguments(argc, argv)");
	}

	if MainFunctionReturnType == "void"
	{
		WriteLine("Main(" + args.ToString() + ");");
		WriteLine("return 0;");
	}
	else
	{
		WriteLine("return Main(" + args.ToString() + ");");
	}

	EndBlock();
}

// ----------------------------------------------------------------------------
// Transpiler
// ----------------------------------------------------------------------------

Transpile(source: string) -> string
{
	Source = source;
	ReadFirstToken();
	ParseProgram();
	return Declarations.ToString() + ClassDeclarations.ToString() + Definitions.ToString();
}

Main(console: mut System.Console.Console, args: System.Console.Arguments) -> void
{
	console.WriteLine("Adamant Compiler v0.1.0");
	if args.Count <> 2
	{
		console.WriteLine("Args: <Input File> <OutputFile>");
		return;
	}

	// Read Source
	let inputFilePath: string = args.Get(0); // TODO should be `args[0]`
	console.Write("Compiling: ");
	console.WriteLine(inputFilePath);
	// TODO should be `new mut`
	let inputFile: mut System.IO.FileReader = new System.IO.FileReader(inputFilePath);
	let source: string = inputFile.ReadToEndSync();
	inputFile.Close();

	let translated: string = Transpile(source);

	// Write output
	let outputFilePath: string = args.Get(1); // TODO should be `args[1]`
	console.Write("Output: ");
	console.WriteLine(outputFilePath);
	// TODO should be `new mut`
	let outputFile: mut System.IO.FileWriter = new System.IO.FileWriter(outputFilePath);
	outputFile.Write(translated);
	outputFile.Close();
}