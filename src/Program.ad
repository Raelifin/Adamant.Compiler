public class SourceText
{
	public let Package: string;
	public let Name: string;
	public let Text: string;

	public new(package: string, name: string, text: string)
	{
		this.Package = package;
		this.Name = name;
		this.Text = text;
	}
}

public class Lexer
{
	public Analyze(source: SourceText) -> mut TokenStream
	{
		return new TokenStream(source);
	}
}

public class TokenStream
{
	public let Source: SourceText;
	private var nextToken: uint;

	public new(source: SourceText)
	{
		Source = source;
		nextToken = 0; // TODO have to assign this zero for now because we don't have default values working
	}

	public GetNextToken() -> string
	{
		var position: uint = nextToken;
		var tokenEnd: uint = -1;
		var escaped: bool;
		var done: bool = false;
		while not done and position < Source.Text.Length
		{
			let curChar: code_point = Source.Text[position];
			if curChar == ' '
				or curChar == '\t'
				or curChar == '\n'
				or curChar == '\r'
			{
				position += 1;
				continue;
			}
			else if curChar == '{'
				or curChar == '}'
				or curChar == '('
				or curChar == ')'
				or curChar == ';'
				or curChar == ','
				or curChar == '.'
				or curChar == ':'
				or curChar == '['
				or curChar == ']'
				or curChar == '?'
			{
				tokenEnd = position + 1;
				break;
			}
			else if curChar == '='
			{
				if position + 1 < Source.Text.Length and Source.Text[position + 1] == '='
				{
					// it is `==`
					tokenEnd = position + 2;
					break;
				}

				// it is `=`
				tokenEnd = position + 1;
				break;
			}
			else if curChar == '+'
			{
				if position + 1 < Source.Text.Length and Source.Text[position + 1] == '='
				{
					// it is `+=`
					tokenEnd = position + 2;
					break;
				}

				// it is `+`
				tokenEnd = position + 1;
				break;
			}
			else if curChar == '-'
			{
				if position + 1 < Source.Text.Length and Source.Text[position + 1] == '>'
				{
					// it is `->`
					tokenEnd = position + 2;
					break;
				}
				if position + 1 < Source.Text.Length and Source.Text[position + 1] == '='
				{
					// it is `-=`
					tokenEnd = position + 2;
					break;
				}
				// it is `-`
				tokenEnd = position + 1;
				break;
			}
			else if curChar == '/'
			{
				if position + 1 < Source.Text.Length and Source.Text[position + 1] == '/'
				{
					// it is a line comment `//`
					while position < Source.Text.Length and Source.Text[position] <> '\r' and Source.Text[position] <> '\n'
					{
						position += 1;
					}

					continue;
				}
				// it is `/`
				tokenEnd = position + 1;
				break;
			}
			else if curChar == '<'
			{
				if position + 1 < Source.Text.Length and Source.Text[position + 1] == '>'
				{
					// it is `<>`
					tokenEnd = position + 2;
					break;
				}
				if position + 1 < Source.Text.Length and Source.Text[position + 1] == '='
				{
					// it is `<=`
					tokenEnd = position + 2;
					break;
				}
				// it is `<`
				tokenEnd = position + 1;
				break;
			}
			else if curChar == '>'
			{
				if position + 1 < Source.Text.Length and Source.Text[position + 1] == '='
				{
					// it is `>=`
					tokenEnd = position + 2;
					break;
				}
				// it is `>`
				tokenEnd = position + 1;
				break;
			}
			else if curChar == '"'
			{
				tokenEnd = position + 1;
				escaped = false;
				while tokenEnd < Source.Text.Length and (Source.Text[tokenEnd] <> '"' or escaped)
				{
					escaped = Source.Text[tokenEnd] == '\\' and not escaped;
					tokenEnd += 1;
				}

				tokenEnd += 1; // To include the close quote
				break;
			}
			else if curChar == '\''
			{
				tokenEnd = position + 1;
				escaped = false;
				while tokenEnd < Source.Text.Length and (Source.Text[tokenEnd] <> '\'' or escaped)
				{
					escaped = Source.Text[tokenEnd] == '\\' and not escaped;
					tokenEnd += 1;
				}

				tokenEnd += 1; // To include the close quote
				break;
			}
			else
			{
				if IsIdentifierChar(curChar)
				{
					tokenEnd = position + 1;
					while IsIdentifierChar(Source.Text[tokenEnd])
					{
						tokenEnd += 1;
					}
					break;
				}
				if(IsNumberChar(curChar))
				{
					tokenEnd = position + 1;
					while IsNumberChar(Source.Text[tokenEnd])
					{
						tokenEnd += 1;
					}
					break;
				}
				Error("Lexer: Invalid character `" + curChar + "`");
				position += 1;
			}
		}

		var token: string;
		if tokenEnd == -1
		{
			token = ""; // TODO need nullable string so we can set it to null
			nextToken = position;
		}
		else
		{
			token = Source.Text.Substring(position, tokenEnd - position);
			nextToken = tokenEnd;
		}

		return token;
	}

	private NewToken(type: TokenType, end: uint) -> SyntaxToken
	{
		//let start: uint = position;
		//position = end;
		//return new SyntaxToken(type, Source, start, end);
		return null;
	}

	private NewToken(type: TokenType) -> SyntaxToken
	{
		//return NewToken(type, position+1);
		return null;
	}
}

// TODO make this an enum struct
public class TokenType
{
	//Keyword,
	//Identifier,
	//LeftParen,
	//RightParen,
	//LeftBrace,
	//RightBrace,
	//LeftBracket,
	//RightBracket,
	//Colon,
	//Dot,
	//Semicolon,
	//Assign,
	//IsNull,
	//Plus,
	//Comma,
}

public class SyntaxToken
{
	public let TokenType: TokenType;
	public let Source: SourceText;
	public let Start: uint;
	public let Length: uint;
	//public Text: string;

	public new(tokenType: TokenType, source: SourceText, start: uint, length: uint)
	{
		TokenType = tokenType;
		Source = source;
		Start = start;
		Length = length;
	}
}

public class Parser
{
	public new()
	{
	}

	public Parse(tokenStream: TokenStream) -> SyntaxNode?
	{
		return null;
	}
}

public class SyntaxNode
{

}

public Parse(source: SourceText) -> SyntaxNode
{
	// TODO should be mut new
	let lexer: mut Lexer = new Lexer(); // TODO remove mut here when we can mark methods as const
	let tokenStream: mut TokenStream = lexer.Analyze(source);
	let parser: mut Parser = new Parser();
	return parser.Parse(tokenStream);
}

public EmitCpp(syntaxTree: SyntaxNode) -> void
{
}

public var tokenStream: mut TokenStream = null;
public var Token: string = "";
// TODO should be `new mut`
public let Declarations: mut System.Text.StringBuilder = new System.Text.StringBuilder();
public let ClassDeclarations: mut System.Text.StringBuilder = new System.Text.StringBuilder();
public let Definitions: mut System.Text.StringBuilder = new System.Text.StringBuilder();
public var IndentDepth: int = 0;
public var AfterDeclaration: bool = false;
public var MainFunctionReturnType: string = "";
public var MainFunctionAcceptsConsole: bool = false;
public var MainFunctionAcceptsArgs: bool = false;

// ----------------------------------------------------------------------------
// Code Writing
// ----------------------------------------------------------------------------

public Error(message: string) -> void
{
	Definitions.Append("<$ " + message + " $>");
}

public BeginLine(value: string) -> void
{
	if AfterDeclaration
	{
		Definitions.AppendLine();
		AfterDeclaration = false;
	}
	Definitions.Append(new string('\t', IndentDepth));
	Definitions.Append(value);
}

public Write(value: string) -> void
{
	Definitions.Append(value);
}

public EndLine(value: string) -> void
{
	Definitions.Append(value);
	Definitions.AppendLine(); // TODO need to think about the handling of newlines
}

public WriteLine(value: string) -> void
{
	if AfterDeclaration
	{
		Definitions.AppendLine();
		AfterDeclaration = false;
	}
	Definitions.Append(new string('\t', IndentDepth));
	Definitions.Append(value);
	Definitions.AppendLine();
}

public BeginBlock() -> void
{
	WriteLine("{");
	IndentDepth += 1;
}

public EndBlock() -> void
{
	AfterDeclaration = false; // so that we don't put a blank line between two closing braces
	IndentDepth -= 1;
	WriteLine("}");
	AfterDeclaration = true;
}

// ----------------------------------------------------------------------------
// Lexer
// ----------------------------------------------------------------------------

public IsIdentifierChar(c: code_point) -> bool
{
	return (c >= 'a' and c <= 'z') or (c >= 'A' and c <= 'Z') or c == '_';
}

public IsNumberChar(c: code_point) -> bool
{
	return c >= '0' and c <= '9';
}



public TokenIsIdentifier() -> bool
{
	if Token.Length == 0
		{ return false; }

	for let c: code_point in Token
	{
		if not IsIdentifierChar(c)
			{ return false; }
	}
	return true;
}

public Accept(expected: string) -> bool
{
	let accepted: bool = Token == expected;
	if accepted { Token = tokenStream.GetNextToken(); }
	return accepted;
}

public Expect(expected: string) -> void
{
	if Token <> expected
	{
		Error("Expected `" + expected + "` but found `" + Token + "`");
		Token = tokenStream.GetNextToken(); // Skip token to advance
	}
	else
	{
		Token = tokenStream.GetNextToken();
	}
}

public AcceptIdentifier() -> bool
{
	if not TokenIsIdentifier() { return false; }
	Token = tokenStream.GetNextToken();
	return true;
}

public AcceptString() -> bool
{
	if Token.Length == 0 or Token[0] <> '"'
		{ return false; }

	Token = tokenStream.GetNextToken();
	return true;
}

public AcceptCodePoint() -> bool
{
	if Token.Length == 0 or Token[0] <> '\''
		{ return false; }

	Token = tokenStream.GetNextToken();
	return true;
}

public AcceptNumber() -> bool
{
	for let c: code_point in Token
	{
		if not IsNumberChar(c)
			{ return false; }
	}

	Token = tokenStream.GetNextToken();
	return true;
}

public ExpectIdentifier() -> string
{
	if not TokenIsIdentifier()
	{
		Error("Expected identifier, found `" + Token + "`");
		Token = tokenStream.GetNextToken(); // Skip token to advance
		return "<missing>";
	}

	let identifier: string = Token;
	Token = tokenStream.GetNextToken();
	return identifier;
}

// ----------------------------------------------------------------------------
// Parser
// ----------------------------------------------------------------------------

public IsValueType(type: string) -> bool
{
	// Here we assume that they follow convention and value types start lowercase
	let firstChar: code_point = type[0];
	return firstChar >= 'a' and firstChar <= 'z';
}

public ConvertType(type: string) -> string
{
	if type == "code_point"
		{ return "char"; }
	if type == "uint"
		{ return "unsigned int"; }
	if type == "int" or type == "bool" or type == "void"
		{ return type; }

	return "::" + type.Replace(".", "::");
}

public ConvertType(mutableBinding: bool, mutableValue: bool, var type: string) -> string
{
	let nullable: bool = type[type.Length-1] == '?';
	if nullable // remove the `?`
		{ type = type.Substring(0, type.Length-1); }

	let isValueType: bool = IsValueType(type);
	type = ConvertType(type);

	if isValueType
	{
		if nullable
			{ type = "::Maybe<" + type + ">"; }
		if not mutableBinding and not mutableValue
			{ type = type + " const"; }
	}
	else
	{
		if not mutableValue { type = type + " const"; }
		type = type + " *";
		if not mutableBinding { type = type + "const" ; }
	}

	return type;
}

public ParseType() -> string
{
	// TODO should be `new mut`
	let type: mut System.Text.StringBuilder = new System.Text.StringBuilder(ExpectIdentifier());
	while Accept(".")
	{
		type.Append(".");
		type.Append(ExpectIdentifier());
	}
	if Accept("<")
	{
		type.Append("<");
		let mutableValue: bool = Accept("mut");
		type.Append(ConvertType(true, mutableValue, ParseType()));
		Accept(">");
		type.Append(">");
	}

	if Accept("?")
		{ type.Append("?"); }

	return type.ToString();
}

// An Atom is the unit of an expression that occurs between infix operators, i.e. an identifier, literal, group, or new
public ParseAtom() -> bool
{
	if Accept("new")
	{
		// Constructor Call
		var type: string = ParseType();
		if not IsValueType(type) // place value types on the stack in C++ by not using new
			{ Write("new "); }
		type = ConvertType(type);
		Write(type);
		Expect("(");
		Write("(");
		ParseCallArguments();
		Expect(")");
		Write(")");
		return true;
	}
	if Accept("not")
	{
		Write("!");
		ParseExpression();
		return true;
	}
	if Accept("(") // Order of operations parens
	{
		Write("(");
		ParseExpression();
		Expect(")");
		Write(")");
		return true;
	}
	if Accept("-")
	{
		// Unary Minus
		Write("-");
		ParseExpression(7);
		return true;
	}
	if Accept("null")
	{
		Write("::None");
		return true;
	}

	let token: string = Token;
	if AcceptIdentifier() or AcceptNumber()
	{
		Write(token);
		return true;
	}
	if AcceptString()
	{
		Write("::string(" + token + ")");
		return true;
	}
	if AcceptCodePoint()
	{
		Write(token);
		return true;
	}

	return false;
}

public ParseCallArguments() -> void
{
	var first: bool = true;
	do
	{
		if first { first = false; }
		else { Write(", "); }
		ParseExpression();
	} while Accept(",");
}

// Operator Precedence
// 1 Assignment: = += -=
// 2 Logical Or: or
// 3 Logical And: and
// 4 Equality: == <>
// 5 Relational: < <= > >=
// 6 Additive: + -
// 7 Unary: -
// 8 Primary: f() . []
public ParseExpression(minPrecedence: int) -> void
{
	if not ParseAtom() { return; }

	loop
	{
		let token: string = Token;
		var precedence: int;
		var leftAssociative: bool;
		var suffixOperator: bool = false;
		if (token == "=" or token == "+=" or token == "-=") and minPrecedence <= 1
		{
			// Assignment
			precedence = 1;
			leftAssociative = false;
			Write(" " + token + " ");
		}
		else if token == "or" and minPrecedence <= 2
		{
			// logical or
			precedence = 2;
			leftAssociative = true;
			Write(" || ");
		}
		else if token == "and" and minPrecedence <= 3
		{
			// logical and
			precedence = 3;
			leftAssociative = true;
			Write(" && ");
		}
		else if token == "==" and minPrecedence <= 4
		{
			// equal
			precedence = 4;
			leftAssociative = true;
			Write(" == ");
		}
		else if token == "<>" and minPrecedence <= 4
		{
			// not equal
			precedence = 4;
			leftAssociative = true;
			Write(" != ");
		}
		else if (token == "<" or token == "<=" or token == ">" or token == ">=") and minPrecedence <= 5
		{
			// relational operators
			precedence = 5;
			leftAssociative = true;
			Write(" " + token + " ");
		}
		else if (token == "+" or token == "-") and minPrecedence <= 6
		{
			// Additive
			precedence = 6;
			leftAssociative = true;
			Write(" " + token + " ");
		}
		else if token == "(" and minPrecedence <= 8
		{
			// Call Expression
			Token = tokenStream.GetNextToken();
			Write("(");
			ParseCallArguments();
			if Token <> ")"
			{
				Error("Expected `)` found `" + Token + "`");
			}
			Write(")");
			precedence = 8;
			leftAssociative = true;
			suffixOperator = true;
		}
		else if token == "." and minPrecedence <= 8
		{
			// Member Access
			precedence = 8;
			leftAssociative = true;
			Write("->");
		}
		else if token == "[" and minPrecedence <= 8
		{
			// Element Access
			Token = tokenStream.GetNextToken();
			Write("[");
			ParseExpression();
			if Token <> "]"
			{
				Error("Expected `]` found `" + Token + "`");
			}
			Write("]");
			precedence = 8;
			leftAssociative = true;
			suffixOperator = true;
		}
		else
		{
			break;
		}

		Token = tokenStream.GetNextToken();
		if not suffixOperator
		{
			if leftAssociative { precedence += 1; }
			ParseExpression(precedence);
		}
	}
}

public ParseExpression() -> void
{
	ParseExpression(1);
}

public ParseStatement() -> bool
{
	if Accept("return")
	{
		if  Accept(";")
			{ WriteLine("return;"); }
		else
		{
			BeginLine("return ");
			ParseExpression();
			Expect(";");
			EndLine(";");
		}
		return true;
	}
	if Accept("loop")
	{
		WriteLine("for (;;)");
		ParseBlock();
		return true;
	}
	if Accept("while")
	{
		BeginLine("while (");
		ParseExpression();
		EndLine(")");
		ParseBlock();
		return true;
	}
	if Accept("for")
	{
		BeginLine("for (");
		let k: string = Token;
		if not Accept("let") and not Accept("var")
			{ Error("Expected `let` or `var` but found `" + Token + "`"); }
		let name: string = ExpectIdentifier();
		Expect(":");
		let mutableValue: bool = Accept("mut");
		let type: string = ParseType();
		Write(ConvertType(k == "var", mutableValue, type) + " " + name);
		Expect("in");
		Write(" : *(");
		ParseExpression();
		EndLine("))");
		ParseBlock();
		return true;
	}
	if Accept("do")
	{
		WriteLine("do");
		ParseBlock();
		AfterDeclaration = false;
		Expect("while");
		BeginLine("while (");
		ParseExpression();
		Expect(";");
		EndLine(");");
		return true;
	}

	if Accept("if")
	{
		BeginLine("if (");
		ParseExpression();
		EndLine(")");
		ParseBlock();
		while Accept("else")
		{
			AfterDeclaration = false;
			if Accept("if")
			{
				BeginLine("else if (");
				ParseExpression();
				EndLine(")");
				ParseBlock();
			}
			else
			{
				WriteLine("else");
				ParseBlock();
				return true;
			}
		}
		return true;
	}
	let kind: string = Token;
	if Accept("let") or Accept("var")
	{
		let variableName: string = ExpectIdentifier();
		Expect(":");
		let mutableValue: bool = Accept("mut");
		var variableType: string = ParseType();
		variableType = ConvertType(kind == "var", mutableValue, variableType);
		BeginLine(variableType);
		Write(" " + variableName);
		if Accept("=")
		{
			Write(" = ");
			ParseExpression();
		}
		Expect(";");
		EndLine(";");
		return true;
	}
	if Token == "}" { return false; }

	// Assume it is an expression statement
	BeginLine("");
	ParseExpression();
	Expect(";");
	EndLine(";");
	return true;
}

public ParseBlock() -> void
{
	Expect("{");
	BeginBlock();
	while ParseStatement() {}
	Expect("}");
	EndBlock();
}

public ParseArgumentsDeclaration(isMainFunction: bool) -> string
{
	Expect("(");
	if Accept(")") { return ""; }

	// TODO should be `new mut`
	let arguments: mut System.Text.StringBuilder = new System.Text.StringBuilder();
	do
	{
		let mutableBinding: bool = Accept("var");
		let name: string = ExpectIdentifier();
		Expect(":");
		let mutableValue: bool = Accept("mut");
		let type: string = ParseType();
		if isMainFunction
		{
			if type == "System.Console.Console"
				{ MainFunctionAcceptsConsole = true; }
			if type == "System.Console.Arguments"
				{ MainFunctionAcceptsArgs = true; }
		}
		arguments.Append(ConvertType(mutableBinding, mutableValue, type) + " " + name + ", ");
	} while Accept(",");
	Expect(")");
	let result: string = arguments.ToString();
	// TODO implement shortening of StringBuilder
	return result.Substring(0, result.Length - 2); // remove the trailing comma and space
}

public ParseClassMember(className: string) -> void
{
	let accessModifier: string = Token;
	if Accept("public") or Accept("internal") or Accept("protected") or Accept("private")
	{
		// TODO currently not doing anything with the access modifier
	}
	else
	{
		Error("Expected access modifier, found `" + accessModifier + "`");
	}

	if Accept("new")
	{
		// Constructor
		let arguments: string = ParseArgumentsDeclaration(false);
		// Write out the function declaration for C++ so we can call functions defined after others
		ClassDeclarations.AppendLine("\t" + className + "(" + arguments + ");");
		WriteLine("::" + className + "::" + className + "(" + arguments + ")");
		ParseBlock();
		return;
	}

	let kind: string = Token;
	if Accept("var") or Accept("let")
	{
		let fieldName: string = ExpectIdentifier();
		Expect(":");
		let mutableValue: bool = Accept("mut");
		var fieldType: string = ParseType();
		fieldType = ConvertType(true, mutableValue, fieldType); // because we need to assign them in constructors don't mark fields const
		Expect(";");
		ClassDeclarations.AppendLine("\t" + fieldType + " " + fieldName + ";");
		return;
	}

	// Method Declaration
	let methodName: string = ExpectIdentifier();
	let arguments: string = ParseArgumentsDeclaration(false);
	Expect("->");
	let mutableValue: bool = Accept("mut");
	let returnType: string = ParseType();
	let convertedReturnType: string = ConvertType(true, mutableValue, returnType);
	ClassDeclarations.AppendLine("\tauto " + methodName + "(" + arguments + ") -> " + convertedReturnType + ";");
	WriteLine("auto ::" + className + "::" + methodName + "(" + arguments + ") -> " + convertedReturnType);
	ParseBlock();
}

public ParseDeclaration() -> void
{
	let accessModifier: string = Token;
	if Accept("public") or Accept("internal")
	{
		// TODO currently not doing anything with the access modifier
	}
	else
	{
		Error("Expected access modifier, found `" + accessModifier + "`");
	}

	// Static Variable Declaration
	let kind: string = Token;
	if Accept("var") or Accept("let")
	{
		let variableName: string = ExpectIdentifier();
		Expect(":");
		let mutableValue: bool = Accept("mut");
		var variableType: string = ParseType();
		Expect("=");
		variableType = ConvertType(kind == "var", mutableValue, variableType);
		BeginLine(variableType);
		Write(" " + variableName + " = ");
		ParseExpression();
		Expect(";");
		EndLine(";");
		AfterDeclaration = true;
		return;
	}

	if Accept("class")
	{
		let className: string = ExpectIdentifier();
		Declarations.AppendLine("class " + className + ";");
		ClassDeclarations.AppendLine("class " + className);
		Expect("{");
		ClassDeclarations.AppendLine("{");
		ClassDeclarations.AppendLine("public:");
		while not Accept("}")
		{
			ParseClassMember(className);
		}
		ClassDeclarations.AppendLine("};");
		return;
	}

	if Accept("enum")
	{
		Expect("struct");
		let enumName: string = ExpectIdentifier();
		Declarations.AppendLine("enum class " + enumName + ";");
		ClassDeclarations.AppendLine("enum class " + enumName);
		Expect("{");
		ClassDeclarations.AppendLine("{");
		do
		{
			let enumValue: string = ExpectIdentifier();
			ClassDeclarations.Append("\t" + enumValue);
			if Accept("=")
			{
				ClassDeclarations.Append(" = ");
				let value: string = Token;
				if  AcceptNumber()
					{ ClassDeclarations.Append(value); }
				else
					{ Error("Expected number found `"+ value + "`"); }
			}
			ClassDeclarations.AppendLine(",");
		} while Accept(",");
		Expect("}");
		ClassDeclarations.AppendLine("};");
		return;
	}

	// Function Declaration
	let name: string = ExpectIdentifier();
	let arguments: string = ParseArgumentsDeclaration(name == "Main");
	Expect("->");
	let mutableValue: bool = Accept("mut");
	let returnType: string = ParseType();
	let convertedReturnType: string = ConvertType(true, mutableValue, returnType);
	// Write out the function declaration for C++ so we can call functions defined after others
	Declarations.AppendLine("auto " + name + "(" + arguments + ") -> " + convertedReturnType + ";");
	WriteLine("auto " + name + "(" + arguments + ") -> " + convertedReturnType);
	if name == "Main"
	{
		if MainFunctionReturnType <> ""
			{ Error("Multiple declarations of main"); }
		MainFunctionReturnType = returnType;
	}
	ParseBlock();
}

public ParseProgram() -> void
{
	// Setup the beginning of each section
	Declarations.AppendLine("#include \"runtime.h\"");
	Declarations.AppendLine("");
	Declarations.AppendLine("// Declarations");
	ClassDeclarations.AppendLine("");
	ClassDeclarations.AppendLine("// Class Declarations");
	WriteLine("");
	WriteLine("// Definitions");

	do
	{
		ParseDeclaration();
	} while TokenIsIdentifier();
	WriteLine("// Entry Point Adapter");
	WriteLine("int main(int argc, char const *const * argv)");
	BeginBlock();

	// TODO should be `new mut`
	let args: mut System.Text.StringBuilder = new System.Text.StringBuilder();
	if MainFunctionAcceptsConsole
		{ args.Append("new ::System::Console::Console()"); }
	if MainFunctionAcceptsArgs
	{
		if MainFunctionAcceptsConsole
			{ args.Append(", "); }
		args.Append("new ::System::Console::Arguments(argc, argv)");
	}

	if MainFunctionReturnType == "void"
	{
		WriteLine("Main(" + args.ToString() + ");");
		WriteLine("return 0;");
	}
	else
	{
		WriteLine("return Main(" + args.ToString() + ");");
	}

	EndBlock();
}

// ----------------------------------------------------------------------------
// Transpiler
// ----------------------------------------------------------------------------

public Transpile(source: SourceText) -> string
{
	let lexer: mut Lexer = new Lexer(); // TODO remove mut when not needed
	tokenStream = lexer.Analyze(source);
	Token = tokenStream.GetNextToken();
	ParseProgram();
	return Declarations.ToString() + ClassDeclarations.ToString() + Definitions.ToString();
}

public Main(console: mut System.Console.Console, args: System.Console.Arguments) -> void
{
	console.WriteLine("Adamant Compiler v0.1.0");
	if args.Count <> 2
	{
		console.WriteLine("Args: <Input File> <OutputFile>");
		return;
	}

	// Read Source
	let inputFilePath: string = args.Get(0); // TODO should be `args[0]`
	console.Write("Compiling: ");
	console.WriteLine(inputFilePath);
	let source: SourceText = ReadSource(inputFilePath);

	let translated: string = Transpile(source);

	// Write output
	let outputFilePath: string = args.Get(1); // TODO should be `args[1]`
	console.Write("Output: ");
	console.WriteLine(outputFilePath);
	// TODO should be `new mut`
	let outputFile: mut System.IO.FileWriter = new System.IO.FileWriter(outputFilePath);
	outputFile.Write(translated);
	outputFile.Close();
}

public ReadSource(path: string) -> SourceText
{
	// TODO should be `mut new` or `new mut`, whichever is decided to be the correct syntax
	let file: mut System.IO.FileReader = new System.IO.FileReader(path);
	let contents: string = file.ReadToEndSync();
	file.Close(); // TODO this should automatically be handled
	return new SourceText("<default>", path, contents);
}
