public Parse(source: SourceText) -> SyntaxNode
{
	// TODO should be mut new
	let lexer: mut Lexer = new Lexer(); // TODO remove mut here when we can mark methods as const
	let tokenStream: mut TokenStream = lexer.Analyze(source);
	let parser: mut Parser = new Parser();
	return parser.Parse(tokenStream);
}

public EmitCpp(syntaxTree: SyntaxNode) -> void
{
}

public var tokenStream: mut TokenStream = null;
public var Token: string = "";
// TODO should be `new mut`
public let TypeDeclarations: mut System.Text.StringBuilder = new System.Text.StringBuilder();
public let FunctionDeclarations: mut System.Text.StringBuilder = new System.Text.StringBuilder();
public let ClassDeclarations: mut System.Text.StringBuilder = new System.Text.StringBuilder();
public let Definitions: mut System.Text.StringBuilder = new System.Text.StringBuilder();
public var IndentDepth: int = 0;
public var AfterDeclaration: bool = false;
public var MainFunctionReturnType: string = "";
public var MainFunctionAcceptsConsole: bool = false;
public var MainFunctionAcceptsArgs: bool = false;

// ----------------------------------------------------------------------------
// Code Writing
// ----------------------------------------------------------------------------

public Error(message: string) -> void
{
	Definitions.Append("<$ " + message + " $>");
}

public BeginLine(value: string) -> void
{
	if AfterDeclaration
	{
		Definitions.AppendLine();
		AfterDeclaration = false;
	}
	Definitions.Append(new string('\t', IndentDepth));
	Definitions.Append(value);
}

public Write(value: string) -> void
{
	Definitions.Append(value);
}

public EndLine(value: string) -> void
{
	Definitions.Append(value);
	Definitions.AppendLine(); // TODO need to think about the handling of newlines
}

public WriteLine(value: string) -> void
{
	if AfterDeclaration
	{
		Definitions.AppendLine();
		AfterDeclaration = false;
	}
	Definitions.Append(new string('\t', IndentDepth));
	Definitions.Append(value);
	Definitions.AppendLine();
}

public BeginBlock() -> void
{
	WriteLine("{");
	IndentDepth += 1;
}

public EndBlock() -> void
{
	AfterDeclaration = false; // so that we don't put a blank line between two closing braces
	IndentDepth -= 1;
	WriteLine("}");
	AfterDeclaration = true;
}

// ----------------------------------------------------------------------------
// Lexer
// ----------------------------------------------------------------------------

public IsIdentifierChar(c: code_point) -> bool
{
	return (c >= 'a' and c <= 'z') or (c >= 'A' and c <= 'Z') or c == '_';
}

public IsNumberChar(c: code_point) -> bool
{
	return c >= '0' and c <= '9';
}

public TokenIsIdentifier() -> bool
{
	if Token.Length == 0
		{ return false; }

	for let c: code_point in Token
	{
		if not IsIdentifierChar(c)
			{ return false; }
	}
	return true;
}

public Accept(expected: string) -> bool
{
	let accepted: bool = Token == expected;
	if accepted { Token = tokenStream.GetNextToken(); }
	return accepted;
}

public Expect(expected: string) -> void
{
	if Token <> expected
	{
		Error("Expected `" + expected + "` but found `" + Token + "`");
		Token = tokenStream.GetNextToken(); // Skip token to advance
	}
	else
	{
		Token = tokenStream.GetNextToken();
	}
}

public AcceptIdentifier() -> bool
{
	if not TokenIsIdentifier() { return false; }
	Token = tokenStream.GetNextToken();
	return true;
}

public AcceptString() -> bool
{
	if Token.Length == 0 or Token[0] <> '"'
		{ return false; }

	Token = tokenStream.GetNextToken();
	return true;
}

public AcceptCodePoint() -> bool
{
	if Token.Length == 0 or Token[0] <> '\''
		{ return false; }

	Token = tokenStream.GetNextToken();
	return true;
}

public AcceptNumber() -> bool
{
	for let c: code_point in Token
	{
		if not IsNumberChar(c)
			{ return false; }
	}

	Token = tokenStream.GetNextToken();
	return true;
}

public ExpectIdentifier() -> string
{
	if not TokenIsIdentifier()
	{
		Error("Expected identifier, found `" + Token + "`");
		Token = tokenStream.GetNextToken(); // Skip token to advance
		return "<missing>";
	}

	let identifier: string = Token;
	Token = tokenStream.GetNextToken();
	return identifier;
}

// ----------------------------------------------------------------------------
// Parser
// ----------------------------------------------------------------------------

public IsValueType(type: string) -> bool
{
	// Here we assume that they follow convention and value types start lowercase
	let firstChar: code_point = type[0];
	return firstChar >= 'a' and firstChar <= 'z';
}

public ConvertType(type: string) -> string
{
	if type == "code_point"
		{ return "char"; }
	if type == "uint"
		{ return "unsigned int"; }
	if type == "int" or type == "bool" or type == "void" or type == "string"
		{ return type; }

	let cppType: string = "::" + type.Replace(".", "_::").Replace("<", "_<");
	if cppType[cppType.Length-1]=='>'
	{
		return cppType;
	}
	return  cppType + "_";
}

public ConvertType(mutableBinding: bool, mutableValue: bool, var type: string) -> string
{
	let nullable: bool = type[type.Length-1] == '?';
	if nullable // remove the `?`
		{ type = type.Substring(0, type.Length-1); }

	let isValueType: bool = IsValueType(type);
	type = ConvertType(type);

	if isValueType
	{
		if nullable
			{ type = "::Maybe<" + type + ">"; }
		if not mutableBinding and not mutableValue
			{ type = type + " const"; }
	}
	else
	{
		if not mutableValue { type = type + " const"; }
		type = type + " *";
		if not mutableBinding { type = type + "const" ; }
	}

	return type;
}

public ParseType() -> string
{
	// TODO should be `new mut`
	let type: mut System.Text.StringBuilder = new System.Text.StringBuilder(ExpectIdentifier());
	while Accept(".")
	{
		type.Append(".");
		type.Append(ExpectIdentifier());
	}
	if Accept("<")
	{
		type.Append("<");
		let mutableValue: bool = Accept("mut");
		type.Append(ConvertType(true, mutableValue, ParseType()));
		Accept(">");
		type.Append(">");
	}

	if Accept("?")
		{ type.Append("?"); }

	return type.ToString();
}

// An Atom is the unit of an expression that occurs between infix operators, i.e. an identifier, literal, group, or new
public ParseAtom() -> bool
{
	if Accept("new")
	{
		// Constructor Call
		var type: string = ParseType();
		if not IsValueType(type) // place value types on the stack in C++ by not using new
			{ Write("new "); }
		type = ConvertType(type);
		Write(type);
		Expect("(");
		Write("(");
		ParseCallArguments();
		Expect(")");
		Write(")");
		return true;
	}
	if Accept("not")
	{
		Write("!");
		ParseExpression();
		return true;
	}
	if Accept("(") // Order of operations parens
	{
		Write("(");
		ParseExpression();
		Expect(")");
		Write(")");
		return true;
	}
	if Accept("-")
	{
		// Unary Minus
		Write("-");
		ParseExpression(7);
		return true;
	}
	if Accept("null")
	{
		Write("::None");
		return true;
	}
	if Accept("self")
	{
		Write("this");
		return true;
	}

	let token: string = Token;
	if Accept("true")
		or Accept("false")
		or AcceptNumber()
	{
		Write(token);
		return true;
	}
	if AcceptIdentifier()
	{
		Write(token + "_");
		return true;
	}
	if AcceptString()
	{
		Write("string(" + token + ")");
		return true;
	}
	if AcceptCodePoint()
	{
		Write(token);
		return true;
	}

	return false;
}

public ParseCallArguments() -> void
{
	var first: bool = true;
	do
	{
		if first { first = false; }
		else { Write(", "); }
		ParseExpression();
	} while Accept(",");
}

// Operator Precedence
// 1 Assignment: = += -=
// 2 Logical Or: or
// 3 Logical And: and
// 4 Equality: == <>
// 5 Relational: < <= > >=
// 6 Additive: + -
// 7 Unary: -
// 8 Primary: f() . []
public ParseExpression(minPrecedence: int) -> void
{
	if not ParseAtom() { return; }

	loop
	{
		let token: string = Token;
		var precedence: int;
		var leftAssociative: bool;
		var suffixOperator: bool = false;
		if (token == "=" or token == "+=" or token == "-=") and minPrecedence <= 1
		{
			// Assignment
			precedence = 1;
			leftAssociative = false;
			Write(" " + token + " ");
		}
		else if token == "or" and minPrecedence <= 2
		{
			// logical or
			precedence = 2;
			leftAssociative = true;
			Write(" || ");
		}
		else if token == "and" and minPrecedence <= 3
		{
			// logical and
			precedence = 3;
			leftAssociative = true;
			Write(" && ");
		}
		else if token == "==" and minPrecedence <= 4
		{
			// equal
			precedence = 4;
			leftAssociative = true;
			Write(" == ");
		}
		else if token == "<>" and minPrecedence <= 4
		{
			// not equal
			precedence = 4;
			leftAssociative = true;
			Write(" != ");
		}
		else if (token == "<" or token == "<=" or token == ">" or token == ">=") and minPrecedence <= 5
		{
			// relational operators
			precedence = 5;
			leftAssociative = true;
			Write(" " + token + " ");
		}
		else if (token == "+" or token == "-") and minPrecedence <= 6
		{
			// Additive
			precedence = 6;
			leftAssociative = true;
			Write(" " + token + " ");
		}
		else if token == "(" and minPrecedence <= 8
		{
			// Call Expression
			Token = tokenStream.GetNextToken();
			Write("(");
			ParseCallArguments();
			if Token <> ")"
			{
				Error("Expected `)` found `" + Token + "`");
			}
			Write(")");
			precedence = 8;
			leftAssociative = true;
			suffixOperator = true;
		}
		else if token == "." and minPrecedence <= 8
		{
			// Member Access
			precedence = 8;
			leftAssociative = true;
			Write("->");
		}
		else if token == "[" and minPrecedence <= 8
		{
			// Element Access
			Token = tokenStream.GetNextToken();
			Write("[");
			ParseExpression();
			if Token <> "]"
			{
				Error("Expected `]` found `" + Token + "`");
			}
			Write("]");
			precedence = 8;
			leftAssociative = true;
			suffixOperator = true;
		}
		else
		{
			break;
		}

		Token = tokenStream.GetNextToken();
		if not suffixOperator
		{
			if leftAssociative { precedence += 1; }
			ParseExpression(precedence);
		}
	}
}

public ParseExpression() -> void
{
	ParseExpression(1);
}

public ParseStatement() -> bool
{
	if Accept("return")
	{
		if  Accept(";")
			{ WriteLine("return;"); }
		else
		{
			BeginLine("return ");
			ParseExpression();
			Expect(";");
			EndLine(";");
		}
		return true;
	}
	if Accept("loop")
	{
		WriteLine("for (;;)");
		ParseBlock();
		return true;
	}
	if Accept("while")
	{
		BeginLine("while (");
		ParseExpression();
		EndLine(")");
		ParseBlock();
		return true;
	}
	if Accept("for")
	{
		BeginLine("for (");
		let k: string = Token;
		if not Accept("let") and not Accept("var")
			{ Error("Expected `let` or `var` but found `" + Token + "`"); }
		let name: string = ExpectIdentifier();
		Expect(":");
		let mutableValue: bool = Accept("mut");
		let type: string = ParseType();
		Write(ConvertType(k == "var", mutableValue, type) + " " + name + "_");
		Expect("in");
		Write(" : *(");
		ParseExpression();
		EndLine("))");
		ParseBlock();
		return true;
	}
	if Accept("do")
	{
		WriteLine("do");
		ParseBlock();
		AfterDeclaration = false;
		Expect("while");
		BeginLine("while (");
		ParseExpression();
		Expect(";");
		EndLine(");");
		return true;
	}

	if Accept("if")
	{
		BeginLine("if (");
		ParseExpression();
		EndLine(")");
		ParseBlock();
		while Accept("else")
		{
			AfterDeclaration = false;
			if Accept("if")
			{
				BeginLine("else if (");
				ParseExpression();
				EndLine(")");
				ParseBlock();
			}
			else
			{
				WriteLine("else");
				ParseBlock();
				return true;
			}
		}
		return true;
	}
	if Accept("break")
	{
		Expect(";");
		WriteLine("break;");
		return true;
	}
	if Accept("continue")
	{
		Expect(";");
		WriteLine("continue;");
		return true;
	}

	let kind: string = Token;
	if Accept("let") or Accept("var")
	{
		let variableName: string = ExpectIdentifier();
		Expect(":");
		let mutableValue: bool = Accept("mut");
		var variableType: string = ParseType();
		variableType = ConvertType(kind == "var", mutableValue, variableType);
		BeginLine(variableType);
		Write(" " + variableName + "_");
		if Accept("=")
		{
			Write(" = ");
			ParseExpression();
		}
		Expect(";");
		EndLine(";");
		return true;
	}
	if Token == "}" { return false; }

	// Assume it is an expression statement
	BeginLine("");
	ParseExpression();
	Expect(";");
	EndLine(";");
	return true;
}

public ParseBlock() -> void
{
	Expect("{");
	BeginBlock();
	while ParseStatement() {}
	Expect("}");
	EndBlock();
}

public ParseArgumentsDeclaration(isMainFunction: bool, isMethod: bool) -> string
{
	// For methods, this is already consumed becuase of the self param
	if not isMethod { Expect("("); }
	if Accept(")") { return ""; }

	// TODO should be `new mut`
	let arguments: mut System.Text.StringBuilder = new System.Text.StringBuilder();
	do
	{
		let mutableBinding: bool = Accept("var");
		let name: string = ExpectIdentifier();
		Expect(":");
		let mutableValue: bool = Accept("mut");
		let type: string = ParseType();
		if isMainFunction
		{
			if type == "System.Console.Console"
				{ MainFunctionAcceptsConsole = true; }
			if type == "System.Console.Arguments"
				{ MainFunctionAcceptsArgs = true; }
		}
		arguments.Append(ConvertType(mutableBinding, mutableValue, type) + " " + name + "_, ");
	} while Accept(",");
	Expect(")");
	let result: string = arguments.ToString();
	// TODO implement shortening of StringBuilder
	return result.Substring(0, result.Length - 2); // remove the trailing comma and space
}

public ParseConstructorArgumentsDeclaration() -> string
{
	return ParseArgumentsDeclaration(false, false);
}

public ParseFunctionArgumentsDeclaration(isMainFunction: bool) -> string
{
	return ParseArgumentsDeclaration(isMainFunction, false);
}

public ParseMethodArgumentsDeclaration() -> string
{
	return ParseArgumentsDeclaration(false, true);
}

public ParseClassMember(className: string) -> void
{
	let accessModifier: string = Token;
	if Accept("public") or Accept("internal") or Accept("protected") or Accept("private")
	{
		// TODO currently not doing anything with the access modifier
	}
	else
	{
		Error("Expected access modifier, found `" + accessModifier + "`");
	}

	if Accept("new")
	{
		// Constructor
		let arguments: string = ParseConstructorArgumentsDeclaration();
		// Write out the function declaration for C++ so we can call functions defined after others
		ClassDeclarations.AppendLine("\t" + className + "_(" + arguments + ");");
		WriteLine("::" + className + "_::" + className + "_(" + arguments + ")");
		ParseBlock();
		return;
	}

	let kind: string = Token;
	if Accept("var") or Accept("let")
	{
		let fieldName: string = ExpectIdentifier();
		Expect(":");
		let mutableValue: bool = Accept("mut");
		var fieldType: string = ParseType();
		fieldType = ConvertType(true, mutableValue, fieldType); // because we need to assign them in constructors don't mark fields const
		Expect(";");
		ClassDeclarations.AppendLine("\t" + fieldType + " " + fieldName + "_;");
		return;
	}

	// Method Declaration
	let methodName: string = ExpectIdentifier();
	Expect("(");
	let mutableSelf: bool = Accept("mut");
	var isAssociatedFuntion: bool = not mutableSelf;
	if mutableSelf
	{
		Expect("self");
		if Token <> ")"
			{ Expect(","); }
	}
	else
	{
		if Accept("self")
		{
			isAssociatedFuntion = false;
			if Token <> ")"
				{ Expect(","); }
		}
	}
	let arguments: string = ParseMethodArgumentsDeclaration();
	Expect("->");
	let mutableValue: bool = Accept("mut");
	let returnType: string = ParseType();
	let convertedReturnType: string = ConvertType(true, mutableValue, returnType);
	ClassDeclarations.AppendLine("\tauto " + methodName + "_(" + arguments + ") -> " + convertedReturnType + ";");
	WriteLine("auto ::" + className + "_::" + methodName + "_(" + arguments + ") -> " + convertedReturnType);
	ParseBlock();
}

public ParseDeclaration() -> void
{
	let accessModifier: string = Token;
	if Accept("public") or Accept("internal")
	{
		// TODO currently not doing anything with the access modifier
	}
	else
	{
		Error("Expected access modifier, found `" + accessModifier + "`");
	}

	// Static Variable Declaration
	let kind: string = Token;
	if Accept("var") or Accept("let")
	{
		let variableName: string = ExpectIdentifier();
		Expect(":");
		let mutableValue: bool = Accept("mut");
		var variableType: string = ParseType();
		Expect("=");
		variableType = ConvertType(kind == "var", mutableValue, variableType);
		BeginLine(variableType);
		Write(" " + variableName + "_ = ");
		ParseExpression();
		Expect(";");
		EndLine(";");
		AfterDeclaration = true;
		return;
	}

	if Accept("class")
	{
		let className: string = ExpectIdentifier();
		TypeDeclarations.AppendLine("class " + className + "_;");
		ClassDeclarations.AppendLine("class " + className + "_");
		Expect("{");
		ClassDeclarations.AppendLine("{");
		ClassDeclarations.AppendLine("public:");
		while not Accept("}")
		{
			ParseClassMember(className);
		}
		ClassDeclarations.AppendLine("};");
		return;
	}

	if Accept("enum")
	{
		Expect("struct");
		let enumName: string = ExpectIdentifier();
		TypeDeclarations.AppendLine("enum class " + enumName + "_;");
		ClassDeclarations.AppendLine("enum class " + enumName + "_");
		Expect("{");
		ClassDeclarations.AppendLine("{");
		do
		{
			let enumValue: string = ExpectIdentifier();
			ClassDeclarations.Append("\t" + enumValue + "_");
			if Accept("=")
			{
				ClassDeclarations.Append(" = ");
				let value: string = Token;
				if  AcceptNumber()
					{ ClassDeclarations.Append(value); }
				else
					{ Error("Expected number found `"+ value + "`"); }
			}
			ClassDeclarations.AppendLine(",");
		} while Accept(",");
		Expect("}");
		ClassDeclarations.AppendLine("};");
		return;
	}

	// Function Declaration
	let name: string = ExpectIdentifier();
	let arguments: string = ParseFunctionArgumentsDeclaration(name == "Main");
	Expect("->");
	let mutableValue: bool = Accept("mut");
	let returnType: string = ParseType();
	let convertedReturnType: string = ConvertType(true, mutableValue, returnType);
	// Write out the function declaration for C++ so we can call functions defined after others
	FunctionDeclarations.AppendLine("auto " + name + "_(" + arguments + ") -> " + convertedReturnType + ";");
	WriteLine("auto " + name + "_(" + arguments + ") -> " + convertedReturnType);
	if name == "Main"
	{
		if MainFunctionReturnType <> ""
			{ Error("Multiple declarations of main"); }
		MainFunctionReturnType = returnType;
	}
	ParseBlock();
}

public ParseCompilationUnit() -> void
{
	while TokenIsIdentifier()
	{
		ParseDeclaration();
	}
}

public EmitPreamble() -> void
{
	// Setup the beginning of each section
	TypeDeclarations.AppendLine("#include \"RuntimeLibrary.h\"");
	TypeDeclarations.AppendLine("");
	TypeDeclarations.AppendLine("// Type Declarations");
	FunctionDeclarations.AppendLine("");
	FunctionDeclarations.AppendLine("// Function Declarations");
	ClassDeclarations.AppendLine("");
	ClassDeclarations.AppendLine("// Class Declarations");
	WriteLine("");
	WriteLine("// Definitions");
}

public EmitEntryPointAdapter(resources: System.Collections.List<SourceText>) -> void
{
	WriteLine("// Entry Point Adapter");
	WriteLine("int main(int argc, char const *const * argv)");
	BeginBlock();

	for let resource: SourceText in resources
	{
		BeginLine("resource_manager_->AddResource(::string(\"");
		Write(resource.Name);
		Write("\"), ::string(\"");
		Write(resource.Text
								.Replace("\\", "\\\\")
								.Replace("\n", "\\n")
								.Replace("\r", "\\r")
								.Replace("\"", "\\\""));
		EndLine("\"));");
	}
	if resources.Length() > 0
	{
		EndLine(""); // Use EndLine to avoid having an indent on a blank line
	}

	// TODO should be `new mut`
	let args: mut System.Text.StringBuilder = new System.Text.StringBuilder();
	if MainFunctionAcceptsConsole
		{ args.Append("new ::System_::Console_::Console_()"); }
	if MainFunctionAcceptsArgs
	{
		if MainFunctionAcceptsConsole
			{ args.Append(", "); }
		args.Append("new ::System_::Console_::Arguments_(argc, argv)");
	}

	if MainFunctionReturnType == "void"
	{
		WriteLine("Main_(" + args.ToString() + ");");
		WriteLine("return 0;");
	}
	else
	{
		WriteLine("return Main_(" + args.ToString() + ");");
	}

	EndBlock();
}

// ----------------------------------------------------------------------------
// Transpiler
// ----------------------------------------------------------------------------

public Compile(sources: System.Collections.List<SourceText>, resources: System.Collections.List<SourceText>) -> string
{
	EmitPreamble();
	let lexer: mut Lexer = new Lexer(); // TODO remove mut when not needed
	for let source: SourceText in sources
	{
		tokenStream = lexer.Analyze(source);
		Token = tokenStream.GetNextToken();
		ParseCompilationUnit();
	}
	EmitEntryPointAdapter(resources);
	return TypeDeclarations.ToString() + FunctionDeclarations.ToString() + ClassDeclarations.ToString() + Definitions.ToString();
}

public Main(console: mut System.Console.Console, args: System.Console.Arguments) -> void
{
	console.WriteLine("Adamant Compiler v0.1.0");
	let sourceFilePaths: mut System.Collections.List<string> = new System.Collections.List<string>();
	let resourceFilePaths: mut System.Collections.List<string> = new System.Collections.List<string>();
	var outputFilePath: string = "";
	var argType: int = 0; // 0=source file, 1=resource file, 2=output file
	for let arg: string in args
	{
		if argType == 1 // resource file
		{
			resourceFilePaths.Add(arg);
			argType = 0;
		}
		else if argType == 2 // output file
		{
			outputFilePath = arg;
			argType = 0;
		}
		else // source file TODO check argType == 0
		{
			if arg == "-r"
			{
				argType = 1;
			}
			else if arg == "-o"
			{
				argType = 2;
			}
			else
			{
				sourceFilePaths.Add(arg);
			}
		}
	}

	if sourceFilePaths.Length() == 0 or outputFilePath == ""
	{
		console.WriteLine("Args: <Input File(s)> -o <OutputFile> -r <Resource File>");
		return;
	}

	// Read Resources
	let resources: mut System.Collections.List<SourceText> = new System.Collections.List<SourceText>();
	if resourceFilePaths.Length() > 0
	{
		console.WriteLine("Reading Resources:");
		for let resourceFilePath: string in resourceFilePaths
		{
			console.WriteLine("  " + resourceFilePath);
			resources.Add(ReadSource(resourceFilePath));
		}
	}

	// Read Source(s)
	console.WriteLine("Compiling:");
	let sources: mut System.Collections.List<SourceText> = new System.Collections.List<SourceText>();
	for let sourceFilePath: string in sourceFilePaths
	{
		console.WriteLine("  " + sourceFilePath);
		sources.Add(ReadSource(sourceFilePath));
	}

	let translated: string = Compile(sources, resources);

	// Write output
	console.Write("Output: ");
	console.WriteLine(outputFilePath);
	// TODO should be `new mut`
	let outputFile: mut System.IO.FileWriter = new System.IO.FileWriter(outputFilePath);
	outputFile.Write(translated);
	outputFile.Close();

	// Write RuntimeLibrary
	console.Write("Outputting RuntimeLibrary to: ");
	var outputDirPath: string = outputFilePath;
	var index: int = outputDirPath.LastIndexOf('/');
	if index <> -1
		{ outputDirPath = outputDirPath.Substring(0, index+1); }
	index = outputDirPath.LastIndexOf('\\');
	if index <> -1
		{ outputDirPath = outputDirPath.Substring(0, index+1); }
	console.WriteLine(outputDirPath);
	var resourceFile: mut System.IO.FileWriter = new System.IO.FileWriter(outputDirPath+"RuntimeLibrary.h");
	resourceFile.Write(resource_manager.GetString("RuntimeLibrary.h"));
	resourceFile.Close();
	resourceFile = new System.IO.FileWriter(outputDirPath+"RuntimeLibrary.cpp");
	resourceFile.Write(resource_manager.GetString("RuntimeLibrary.cpp"));
	resourceFile.Close();
}

public ReadSource(path: string) -> SourceText
{
	// TODO should be `mut new` or `new mut`, whichever is decided to be the correct syntax
	let file: mut System.IO.FileReader = new System.IO.FileReader(path);
	let contents: string = file.ReadToEndSync();
	file.Close(); // TODO this should automatically be handled
	var name: string = path;
	var index: int = name.LastIndexOf('/');
	if index <> -1
		{ name = name.Substring(index+1); }
	index = name.LastIndexOf('\\');
	if index <> -1
		{ name = name.Substring(index+1); }
	return new SourceText("<default>", name, contents);
}
